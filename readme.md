# 设计模式

##  组合模式

### 1. 定义

> 将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

### 2. 结构图

![组合模式](./组合模式.png)

### 3. 使用的场合

- 需求中体现了部分与整体的层次结构
- 希望用户可以忽略组合对象和单个对象的不同，统一地使用组合结构中的所有对象

### 4. 优点

- 组合模式可以让用户一致地使用组合结构和单个对象

## 迭代器模式

### 1. 定义

> 提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露该对象的内部表示

### 2. 结构图

![迭代器模式](./迭代器模式.png)

### 3. 使用的场合

- 一个聚集对象，不管对象是什么都需要遍历时，应该考虑使用迭代器模式
- 需要对聚集对象有多种方式遍历时

### 4. 优点

- 分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以不暴露集合的内部结构，又让外部代码透明地访问集合内部数据。

## 单例模式

### 1. 定义

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点
>
> 通常我们可以声明一个全局变量使得一个对象被访问，但不能阻止你实例化多个对象，最好的方法是，让类本身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建，而且他可以提供一个访问该实例的方法。

### 2. 结构图

![单例模式](./单例模式.png)

### 3. 优点

- 保证类只有唯一的实例
- 因为只有一个实例，所以可以控制用户怎样访问以及何时访问它

### 4. 多线程时的单例

- 使用锁来处理

  ```java
  class Singleton{
    public  static Singleton singleton;
    private static final Object object=new Object();
    private Singleton(){}
    public static Singleton getInstance(){
        if(singleton==null){
            synchronized(object){
                if(singleton==null){
                    singleton=new Singleton();
                }
            }
        }
      return singleton;
    } 
  }
  ```

### 5. 懒汉式加载和饿汉式加载

- 懒汉式单例：在第一次被引用时才会实例化，会有多线程访问的安全问题

  ```java
  class Singleton{
    public static Singleton singleton;
    private Singleton(){}
    public static Singleton getInstance(){
        if(singleton==null){
            singleton=new Singleton();
        }
      return singleton;
    }
  }
  ```

- 饿汉式单例：在类被加载时就将自己实例化,会提前占用系统资源

  ```java
  class Singleton{
    public static final Singleton singleton=new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return singleton;
    }
  }
  ```

## 桥接模式

### 1. 定义

>将抽象部分与它的实现部分分离，使它们都可以独立地变化。
>
>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把多角度分离出来让它们独立变化，减少它们之间的耦合

### 2. 结构图

![桥接模式](./桥接模式.png)

### 3. 使用的场合

- 当需要从多角度去分类实现对象，而继承会造成大量的类增加，不能满足开放-封闭原则时，考虑使用桥接模式

### 4. 优点

- 减少类之间的耦合

## 命令模式

### 1. 定义

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可撤销的操作。

### 2. 结构图

![命令模式](./命令模式.png)

### 3. 使用场合

- 需要记录请求日志，以及要支持撤销和重做时，可考虑使用命令模式

### 4. 优点

- 比较容易地设计一个命令队列
- 容易将命令记入日志
- 允许接收请求的一方决定是否接受请求
- 容易实现对请求的撤销和重做
- 加入新的具体命令类不影响其他的类，因此增加新的命令很容易
- 把请求一个操作的对象与知道怎么执行该操作的对象分离开

## 职责链模式 

### 1. 定义

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

### 2. 结构图

![职责链模式](./职责链模式.png)

### 3. 使用的场合

- 当有多个处理请求的对象，而且开始并不确定处理请求的是哪个对象，可以使用职责链模式，将对象连成一条链，让请求沿着该链进行传递

### 4. 优点

- 接收者和发送者都没有对方的明确信息，且链中的对象自己也不知道链的结构，简化对象的相互链接，它们仅需保持一个指向后继者的引用，而不需保持它所有这的候选引用，降低耦合度。
- 可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。

## 中介者模式

### 1. 定义

> 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互

### 2. 结构图

![中介者模式](./中介者模式.png)

### 3. 使用的场合

- 当系统中有多个对象，并且各个对象又相互关联时，可以考虑使用中介者模式来封装对象的交互
- 一组对象以定义良好但是复杂的方式进行通信的场合
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类

### 4. 优缺点

- 优点
  - 减少各个对象之间的耦合，可以对立改变和复用各个对象
  - 对对象之间的交互作了抽象， 将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到他们之间的交互上来，站在一个更宏观的角度看待系统。
- 缺点
  - 中介者控制了集中化，把交互的复杂性变为中介者的复杂性，中介者会比较复杂

## 享元模式

### 1. 定义

> 运用共享技术有效地支持大量细粒度的对象

### 2. 结构图

![享元模式](./享元模式.png)

### 3. 使用的场合

- 如果一个应用程序使用了大量的对象，这些对象造成了大量的存储开销时就应该考虑使用享元模式
- 对象的大多数状态可以是外部状态，如果删除对象的外部状态，可以使用相对较少的共享对象来取代很多组对象，此时可以考虑使用享元模式。

### 4. 优缺点

- 优点
  - 运用享元模式可以有效地支持大量细粒度的对象，节约了大量对象的存储空间
- 缺点
  - 需要维护一个记录了系统所有享元的列表，这需要消耗资源
  - 享元模式使系统更加复杂

## 解释器模式

### 1. 定义

> 给定一个语言，定义他的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。

### 2. 结构图

![解释器模式](./解释器模式.png)

### 3. 使用的场合

- 如果一种特定类型的问题发生的频率足够高，那么就可能值得将该问题的各个实例表述为一个简单语言中的句子，这样就可以构建一个解释器，该解释器通过解释这些句子来解决问题
- 当有一个语言需要解释执行，并且你可以将该语言中的句子抽象为语法树时，就可以使用解释器模式

### 4. 优缺点

- 优点
  - 容易改变和扩展文法。因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。
  - 比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于编写
- 缺点
  - 解释器模式为每一条文法规则都定义了一个类，包含许多规则的文法比较难以维护和管理

# 面向对象设计原则

## 1. 组合/聚合复用原则

> 尽量使用组合/聚合，尽量不要使用类继承

- 聚合：表示一种弱的“拥有“关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
- 组合：表示一种强的”拥有“关系，体现了严格的部分和整体的关系，部分和整体的生命周期一致。